"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseTable = void 0;
const lodash_1 = __importDefault(require("lodash"));
const config_1 = require("./config");
const func_1 = require("./func");
const findMaxColumn = (rows, config) => {
    let maxColumns = 0;
    let spanFromPrevRows = [];
    rows.forEach(row => {
        const cells = func_1.selectCells(row, config);
        let rowColSpan = 0;
        const newSpanFromPrevRows = [];
        // Sum the colSpan from previous rows.
        spanFromPrevRows.forEach(spanFromPrevRow => {
            const { rowSpan, colSpan } = spanFromPrevRow;
            // rowSpan == 0 means to the end of table
            const newRowSpan = rowSpan > 1 ? rowSpan - 1 : 0;
            rowColSpan += colSpan;
            // If the rowSpan is 1, than its colSpan should not affect next row.
            if (newRowSpan > 1 || newRowSpan === 0) {
                newSpanFromPrevRows.push({ rowSpan: newRowSpan, colSpan });
            }
        });
        // Sum the colSpan from current row.
        cells.forEach(cell => {
            const rowSpan = func_1.getRowSpan(cell, config);
            const colSpan = func_1.getColSpan(cell, config);
            rowColSpan += colSpan;
            // If the rowSpan is 1, than its colSpan should not affect next row.
            if (rowSpan > 1 || rowSpan === 0) {
                newSpanFromPrevRows.push({ rowSpan, colSpan });
            }
        });
        spanFromPrevRows = newSpanFromPrevRows;
        maxColumns = rowColSpan > maxColumns ? rowColSpan : maxColumns;
    });
    return maxColumns;
};
const findMaxRow = (rows) => rows.length;
const nothing = Symbol("nothing");
const isNothing = (value) => value === nothing;
const updateTable = (option) => {
    const { table, rowLimit, colSpan, rowIndex, realColIndex, parser, cell } = option;
    for (let j = 0; j < rowLimit; j++) {
        for (let i = 0; i < colSpan; i++) {
            if (!isNothing(table[rowIndex + j][realColIndex + i])) {
                return;
            }
            table[rowIndex + j][realColIndex + i] = parser ? parser(cell) : cell;
        }
    }
};
// Handle overlapping triming
const cleanupNothing = (table) => {
    let lastSymbolCol = -1;
    table.forEach(row => {
        const index = func_1.findLastContinueIndex(row, isNothing);
        if (index > lastSymbolCol) {
            lastSymbolCol = index;
        }
    });
    return lastSymbolCol >= 0
        ? table.map(row => row
            .slice(0, lastSymbolCol)
            .map(value => (isNothing(value) ? undefined : value)))
        : table;
};
const parseTable = (tableElement, option) => {
    const { parser, config: userConfig } = option || {};
    const config = lodash_1.default.defaultsDeep(userConfig, config_1.defaultConfig);
    const rows = func_1.selectRows(tableElement, config);
    const maxColumn = findMaxColumn(rows, config);
    const maxRow = findMaxRow(rows);
    const table = func_1.create2dArrays(maxRow, maxColumn, () => nothing);
    rows.forEach((row, rowIndex) => {
        const cells = func_1.selectCells(row, config);
        cells.forEach((cell, colIndex) => {
            const tableRow = table[rowIndex];
            let realColIndex = colIndex;
            while (!isNothing(tableRow[realColIndex])) {
                realColIndex++;
            }
            const rowSpan = func_1.getRowSpan(cell, config);
            const colSpan = func_1.getColSpan(cell, config);
            // If rowSpan > 1, fill X rows
            // If rowSpan == 0, fill until the end
            const rowLimit = rowSpan >= 1 ? rowSpan : rowSpan === 0 ? maxRow - rowIndex : -1;
            updateTable({
                table,
                rowLimit,
                colSpan,
                rowIndex,
                realColIndex,
                parser,
                cell
            });
        });
    });
    return cleanupNothing(table);
};
exports.parseTable = parseTable;
//# sourceMappingURL=index.js.map